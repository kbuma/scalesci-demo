[{"type": "system", "data": {"content": "You are an expert in optimizing scientific computations on HPC systems. \nYou will help this scientist take their existing code and turn it into a Jupyter notebook \nutilizing dask with improved performance (faster, more interactive).\n\nUseful to know:\nYou almost always put different classes in different files.\nFor Python, you always create an appropriate requirements.txt file.\nFor NodeJS, you always create an appropriate package.json file.\nYou always add a comment briefly describing the purpose of the function definition.\nYou try to add comments explaining very complex bits of logic.\nYou always follow the best practices for the requested languages in terms of describing the code written as a defined\npackage/project.\n\n\nPython toolbelt preferences:\n- pytest\n- dataclasses\n", "additional_kwargs": {}}}, {"type": "human", "data": {"content": "Instructions: I have this scientific computation that I wrote. \nI would like to optimize it such that it runs faster (utilizing parallel computation) and is more interactive.\nI will be running this on an HPC system that has support for dask and slurm.\nI will want to interact with the computation via a Jupyter notebook.\n", "additional_kwargs": {}, "example": false}}, {"type": "human", "data": {"content": "The core classes, functions, and methods that will be necessary are:\n\n1. `LatLonData`: A dataclass to store the latitude and longitude data.\n2. `FilterData`: A dataclass to store the filtering parameters.\n3. `EKEData`: A dataclass to store the EKE data.\n4. `WRFData`: A dataclass to store the WRF data.\n5. `WRFProcessor`: A class to perform the computation and generate the plot.\n\nNow, let's proceed with the implementation of the code.\n\n**lat_lon.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass LatLonData:\n    lat: np.ndarray\n    lon: np.ndarray\n    lat_index_north: int\n    lat_index_south: int\n    lon_index_west: int\n    lon_index_east:\n```\n\n**filter.py**\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass FilterData:\n    order: int\n    fs: float\n    big_period_day: float\n    small_period_day: float\n    low_frequency: float\n    high_frequency: float\n```\n\n**eke.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass EKEData:\n    eke_list: list[np.ndarray]\n    total_eke_list: list[float]\n    total_eke_avg: float\n    eke_avg: np.ndarray\n```\n\n**wrf.py**\n\n```python\nfrom dataclasses import dataclass\nimport xarray as xr\n\n@dataclass\nclass WRFData:\n    u_data: xr.Dataset\n    v_data: xr.Dataset\n    u_4d_full: xr.DataArray\n    v_4d_full: xr.DataArray\n    u_4d: xr.DataArray\n    v_4d: xr.DataArray\n    lat_index_south: int\n    lat_index_north: int\n    lon_index_west: int\n    lon_index_east:\n```\n\n**wrf_processor.py**\n\n```python\nfrom netCDF4 import Dataset\nimport numpy as np\nimport xarray as xr\nimport wrf as wrf\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nfrom matplotlib import rcParams\nimport matplotlib.patches as mpatches\nfrom matplotlib.backends.backend_pdf import PdfPages\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nfrom scipy import signal\nimport scipy.ndimage as ndimage\nimport dask.array as da\nfrom dask.distributed import Client, LocalCluster\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom eke import EKEData\nfrom wrf import WRFData\n\nclass WRFProcessor:\n    def __init__(self, lat_lon_data: LatLonData, filter_data: FilterData):\n        self.lat_lon_data = lat_lon_data\n        self.filter_data = filter_data\n\n    def butter_bandpass_filter(self, variable):\n        print(\"Temporal filter...\")\n        b, a = signal.butter(self.filter_data.order, [self.filter_data.low_frequency, self.filter_data.high_frequency], btype='bandpass')\n        filtered_variable = signal.lfilter(b, a, variable, axis=0)\n        return filtered_variable\n\n    def plot_eke(self, lat, eke_avg):\n        fig, ax = plt.subplots()\n        clevels = np.linspace(-8, 8, 33)\n        cmap = plt.cm.PuOr\n        units = '$\\mathrm{m}^{2}$ $\\mathrm{s}^{-2}$'\n        p_levels = np.linspace(1000, 100, 19)\n        X, Y = np.meshgrid(lat[:, 0], p_levels)\n        plt.xlabel(\"Latitude\")\n        plt.ylabel(\"Pressure (hPa)\")\n        contours_fill = plt.contourf(X, Y, eke_avg, cmap=cmap, levels=clevels, extend=\"both\")\n        ax.set_xlim(-5, 25)\n        plt.minorticks_on()\n        plt.gca().invert_yaxis()\n        cbar = plt.colorbar(contours_fill, shrink=.58, orientation='horizontal')\n        ax.set_aspect(1. / ax.get_data_ratio())\n        fig.savefig('WRF_TCM_M-O_2001-2010avg_' + scenario_type + '_EKE.pdf', bbox_inches='tight')\n\n    def process_wrf_data(self, wrf_data: WRFData) -> EKEData:\n        lat = wrf_data.lat\n        lon = wrf_data.lon\n        lat_index_north = wrf_data.lat_index_north\n        lat_index_south = wrf_data.lat_index_south\n        lon_index_west = wrf_data.lon_index_west\n        lon_index_east = wrf_data.lon_index_east\n\n        eke_list = []\n        total_eke_list = []\n\n        for year in range(2001, 2011):\n            print('Year =', year)\n            file_location = '/global/cscratch1/sd/ebercosh/WRF_TCM/' + scenario_type + '/' + str(year) + '/'\n\n            u_data = xr.open_dataset(file_location + 'ua_' + scenario_type + '_' + str(year) + '.nc')\n            v_data = xr.open_dataset(file_location + 'va_' + scenario_type + '_' + str(year) + '.nc')\n            u_4d_full = u_data.ua\n            v_4d_full = v_data.va\n            u_4d = u_4d_full[:-120, :, :, :]\n            v_4d = v_4d_full[:-120, :, :, :]\n\n            u_temp_filt = self.butter_bandpass_filter(u_4d)\n            v_temp_filt = self.butter_bandpass_filter(v_4d)\n\n            uu = np.square(u_temp_filt)\n            vv = np.square(v_temp_filt)\n\n            uu_3d = np.mean(uu, axis=0)\n            vv_3d = np.mean(vv, axis=0)\n\n            uu_vv_3d = uu_3d + vv_3d\n\n            uu_vv_2d = np.mean(uu_vv_3d[:, :, lon_index_west:lon_index_east + 1], axis=2)\n\n            eke_2d = 0.5 * uu_vv_2d\n            eke_list.append(eke_2d)\n\n            eke_1d = 0.5 * np.mean(uu_vv_2d[:, lat_index_south:lat_index_north + 1] / g, axis=1)\n\n            total_eke = np.trapz(eke_1d, dx=5000., axis=0)\n            total_eke_list.append(total_eke)\n\n        total_eke_avg = np.mean(total_eke_list, axis=0)\n        eke_avg = np.mean(eke_list, axis=0)\n\n        return EKEData(eke_list=eke_list, total_eke_list=total_eke_list, total_eke_avg=total_eke_avg, eke_avg=eke_avg)\n```\n\n**main.py**\n\n```python\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom wrf import WRFData\nfrom wrf_processor import WRFProcessor\n\ndef main():\n    lat_lon_data = LatLonData(lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east)\n    filter_data = FilterData(order=6, fs=1/6, big_period_day=5.0, small_period_day=3.0, low_frequency=0.008333333333333333, high_frequency=0.016666666666666666)\n    wrf_data = WRFData(u_data, v_data, u_4d_full, v_4d_full, u_4d, v_4d, lat_index_south, lat_index_north, lon_index_west, lon_index_east)\n\n    wrf_processor = WRFProcessor(lat_lon_data, filter_data)\n    eke_data = wrf_processor.process_wrf_data(wrf_data)\n\n    eke_avg = eke_data.eke_avg\n    wrf_processor.plot_eke(lat, eke_avg)\n\nif __name__ == \"__main__\":\n    cluster = LocalCluster()\n    client = Client(cluster)\n    main()\n```\n\n**test_wrf_processor.py**\n\n```python\nimport numpy as np\nimport pytest\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom wrf import WRFData\nfrom wrf_processor import WRFProcessor\n\n@pytest.fixture\ndef lat_lon_data():\n    lat = np.array([0, 1, 2, 3, 4])\n    lon = np.array([0, 1, 2, 3, 4])\n    lat_index_north = 4\n    lat_index_south = 0\n    lon_index_west = 0\n    lon_index_east = 4\n    return LatLonData(lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east)\n\n@pytest.fixture\ndef filter_data():\n    return FilterData(order=6, fs=1/6, big_period_day=5.0, small_period_day=3.0, low_frequency=0.008333333333333333, high_frequency=0.016666666666666666)\n\n@pytest.fixture\ndef wrf_data():\n    u_data = None  # Replace with appropriate data\n    v_data = None  # Replace with appropriate data\n    u_4d_full = None  # Replace with appropriate data\n    v_4d_full = None  # Replace with appropriate data\n    u_4d = None  # Replace with appropriate data\n    v_4d = None  # Replace with appropriate data\n    lat_index_south = 0\n    lat_index_north = 4\n    lon_index_west = 0\n    lon_index_east = 4\n    return WRFData(u_data, v_data, u_4d_full, v_4d_full, u_4d, v_4d, lat_index_south, lat_index_north, lon_index_west, lon_index_east)\n\ndef test_butter_bandpass_filter(wrf_data, filter_data):\n    wrf_processor = WRFProcessor(None, filter_data)\n    filtered_variable = wrf_processor.butter_bandpass_filter(wrf_data.u_4d)\n    assert filtered_variable.shape == wrf_data.u_4d.shape\n\ndef test_process_wrf_data(wrf_data, lat_lon_data, filter_data):\n    wrf_processor = WRFProcessor(lat_lon_data, filter_data)\n    eke_data = wrf_processor.process_wrf_data(wrf_data)\n    assert len(eke_data.eke_list) == 10\n    assert len(eke_data.total_eke_list) == 10\n    assert eke_data.total_eke_avg.shape == ()\n    assert eke_data.eke_avg.shape == (5, 5)\n```\n\n**requirements.txt**\n\n```\npytest\nnumpy\nxarray\nmatplotlib\nscipy\ndask\nnetCDF4\n```", "additional_kwargs": {}, "example": false}}, {"type": "system", "data": {"content": "You will get instructions for code to write.\nYou will write a very long answer. Make sure that every detail of the architecture is, in the end, implemented as code.\n\nThink step by step and reason yourself to the right decisions to make sure we get it right.\nYou will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose.\n\nThen you will output the content of each file including ALL code.\nEach file must strictly follow a markdown code block format, where the following tokens must be replaced such that\nFILENAME is the lowercase file name including the file extension,\nLANG is the markup code block language for the code's language, and CODE is the code:\n\nFILENAME\n```LANG\nCODE\n```\n\nDo not comment on what every file does\n\nYou will start with the \"entrypoint\" file, then go to the ones that are imported by that file, and so on.\nPlease note that the code should be fully functional. No placeholders.\n\nFollow a language and framework appropriate best practice file naming convention.\nMake sure that files contain all imports, types etc. Make sure that code in different files are compatible with each other.\nEnsure to implement all code, if you are unsure, write a plausible implementation.\nInclude module dependency or package manager dependency definition file.\nBefore you finish, double check that all parts of the architecture is present in the files.\n", "additional_kwargs": {}}}, {"type": "human", "data": {"content": "Rewrite the provided code to incorporate the following improvement: \nOptimize the code by removing unnecessary imports and variables.\n\nPlease now remember the steps:\n\nThink step by step and reason yourself to the right decisions to make sure we get it right.\nFirst lay out the names of the core classes, functions, methods that will be necessary, As well as a quick comment on their purpose.\n\nThen you will output the content of each file including ALL code.\nEach file must strictly follow a markdown code block format, where the following tokens must be replaced such that\nFILENAME is the lowercase file name including the file extension,\nLANG is the markup code block language for the code's language, and CODE is the code:\n\nFILENAME\n```LANG\nCODE\n```\n\nPlease note that the code should be fully functional. No placeholders.\n\nYou will start with the \"entrypoint\" file, then go to the ones that are imported by that file, and so on.\nFollow a language and framework appropriate best practice file naming convention.\nMake sure that files contain all imports, types etc. The code should be fully functional. Make sure that code in different files are compatible with each other.\nBefore you finish, double check that all parts of the architecture is present in the files.\n", "additional_kwargs": {}, "example": false}}, {"type": "ai", "data": {"content": "The core classes, functions, and methods that will be necessary are:\n\n1. `LatLonData`: A dataclass to store the latitude and longitude data.\n2. `FilterData`: A dataclass to store the filtering parameters.\n3. `EKEData`: A dataclass to store the EKE data.\n4. `WRFData`: A dataclass to store the WRF data.\n5. `WRFProcessor`: A class to perform the computation and generate the plot.\n\nNow, let's proceed with the implementation of the code.\n\n**lat_lon.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass LatLonData:\n    lat: np.ndarray\n    lon: np.ndarray\n    lat_index_north: int\n    lat_index_south: int\n    lon_index_west: int\n    lon_index_east:\n```\n\n**filter.py**\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass FilterData:\n    order: int\n    fs: float\n    big_period_day: float\n    small_period_day: float\n    low_frequency: float\n    high_frequency: float\n```\n\n**eke.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass EKEData:\n    eke_list: list[np.ndarray]\n    total_eke_list: list[float]\n    total_eke_avg: float\n    eke_avg: np.ndarray\n```\n\n**wrf.py**\n\n```python\nfrom dataclasses import dataclass\nimport xarray as xr\n\n@dataclass\nclass WRFData:\n    u_data: xr.Dataset\n    v_data: xr.Dataset\n    u_4d_full: xr.DataArray\n    v_4d_full: xr.DataArray\n    u_4d: xr.DataArray\n    v_4d: xr.DataArray\n    lat_index_south: int\n    lat_index_north: int\n    lon_index_west: int\n    lon_index_east:\n```\n\n**wrf_processor.py**\n\n```python\nimport numpy as np\nimport xarray as xr\nfrom scipy import signal\nimport dask.array as da\nfrom dask.distributed import Client, LocalCluster\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom eke import EKEData\nfrom wrf import WRFData\n\nclass WRFProcessor:\n    def __init__(self, lat_lon_data: LatLonData, filter_data: FilterData):\n        self.lat_lon_data = lat_lon_data\n        self.filter_data = filter_data\n\n    def butter_bandpass_filter(self, variable):\n        print(\"Temporal filter...\")\n        b, a = signal.butter(self.filter_data.order, [self.filter_data.low_frequency, self.filter_data.high_frequency], btype='bandpass')\n        filtered_variable = signal.lfilter(b, a, variable, axis=0)\n        return filtered_variable\n\n    def plot_eke(self, lat, eke_avg):\n        fig, ax = plt.subplots()\n        clevels = np.linspace(-8, 8, 33)\n        cmap = plt.cm.PuOr\n        units = '$\\mathrm{m}^{2}$ $\\mathrm{s}^{-2}$'\n        p_levels = np.linspace(1000, 100, 19)\n        X, Y = np.meshgrid(lat[:, 0], p_levels)\n        plt.xlabel(\"Latitude\")\n        plt.ylabel(\"Pressure (hPa)\")\n        contours_fill = plt.contourf(X, Y, eke_avg, cmap=cmap, levels=clevels, extend=\"both\")\n        ax.set_xlim(-5, 25)\n        plt.minorticks_on()\n        plt.gca().invert_yaxis()\n        cbar = plt.colorbar(contours_fill, shrink=.58, orientation='horizontal')\n        ax.set_aspect(1. / ax.get_data_ratio())\n        fig.savefig('WRF_TCM_M-O_2001-2010avg_' + scenario_type + '_EKE.pdf', bbox_inches='tight')\n\n    def process_wrf_data(self, wrf_data: WRFData) -> EKEData:\n        lat = wrf_data.lat\n        lon = wrf_data.lon\n        lat_index_north = wrf_data.lat_index_north\n        lat_index_south = wrf_data.lat_index_south\n        lon_index_west = wrf_data.lon_index_west\n        lon_index_east = wrf_data.lon_index_east\n\n        eke_list = []\n        total_eke_list = []\n\n        for year in range(2001, 2011):\n            print('Year =', year)\n            file_location = '/global/cscratch1/sd/ebercosh/WRF_TCM/' + scenario_type + '/' + str(year) + '/'\n\n            u_data = xr.open_dataset(file_location + 'ua_' + scenario_type + '_' + str(year) + '.nc')\n            v_data = xr.open_dataset(file_location + 'va_' + scenario_type + '_' + str(year) + '.nc')\n            u_4d_full = u_data.ua\n            v_4d_full = v_data.va\n            u_4d = u_4d_full[:-120, :, :, :]\n            v_4d = v_4d_full[:-120, :, :, :]\n\n            u_temp_filt = self.butter_bandpass_filter(u_4d)\n            v_temp_filt = self.butter_bandpass_filter(v_4d)\n\n            uu = np.square(u_temp_filt)\n            vv = np.square(v_temp_filt)\n\n            uu_3d = np.mean(uu, axis=0)\n            vv_3d = np.mean(vv, axis=0)\n\n            uu_vv_3d = uu_3d + vv_3d\n\n            uu_vv_2d = np.mean(uu_vv_3d[:, :, lon_index_west:lon_index_east + 1], axis=2)\n\n            eke_2d = 0.5 * uu_vv_2d\n            eke_list.append(eke_2d)\n\n            eke_1d = 0.5 * np.mean(uu_vv_2d[:, lat_index_south:lat_index_north + 1] / g, axis=1)\n\n            total_eke = np.trapz(eke_1d, dx=5000., axis=0)\n            total_eke_list.append(total_eke)\n\n        total_eke_avg = np.mean(total_eke_list, axis=0)\n        eke_avg = np.mean(eke_list, axis=0)\n\n        return EKEData(eke_list=eke_list, total_eke_list=total_eke_list, total_eke_avg=total_eke_avg, eke_avg=eke_avg)\n```\n\n**main.py**\n\n```python\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom wrf import WRFData\nfrom wrf_processor import WRFProcessor\n\ndef main():\n    lat_lon_data = LatLonData(lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east)\n    filter_data = FilterData(order=6, fs=1/6, big_period_day=5.0, small_period_day=3.0, low_frequency=0.008333333333333333, high_frequency=0.016666666666666666)\n    wrf_data = WRFData(u_data, v_data, u_4d_full, v_4d_full, u_4d, v_4d, lat_index_south, lat_index_north, lon_index_west, lon_index_east)\n\n    wrf_processor = WRFProcessor(lat_lon_data, filter_data)\n    eke_data = wrf_processor.process_wrf_data(wrf_data)\n\n    eke_avg = eke_data.eke_avg\n    wrf_processor.plot_eke(lat, eke_avg)\n\nif __name__ == \"__main__\":\n    cluster = LocalCluster()\n    client = Client(cluster)\n    main()\n```\n\n**test_wrf_processor.py**\n\n```python\nimport numpy as np\nimport pytest\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom wrf import WRFData\nfrom wrf_processor import WRFProcessor\n\n@pytest.fixture\ndef lat_lon_data():\n    lat = np.array([0, 1, 2, 3, 4])\n    lon = np.array([0, 1, 2, 3, 4])\n    lat_index_north = 4\n    lat_index_south = 0\n    lon_index_west = 0\n    lon_index_east = 4\n    return LatLonData(lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east)\n\n@pytest.fixture\ndef filter_data():\n    return FilterData(order=6, fs=1/6, big_period_day=5.0, small_period_day=3.0, low_frequency=0.008333333333333333, high_frequency=0.016666666666666666)\n\n@pytest.fixture\ndef wrf_data():\n    u_data = None  # Replace with appropriate data\n    v_data = None  # Replace with appropriate data\n    u_4d_full = None  # Replace with appropriate data\n    v_4d_full = None  # Replace with appropriate data\n    u_4d = None  # Replace with appropriate data\n    v_4d = None  # Replace with appropriate data\n    lat_index_south = 0\n    lat_index_north = 4\n    lon_index_west = 0\n    lon_index_east = 4\n    return WRFData(u_data, v_data, u_4d_full, v_4d_full, u_4d, v_4d, lat_index_south, lat_index_north, lon_index_west, lon_index_east)\n\ndef test_butter_bandpass_filter(wrf_data, filter_data):\n    wrf_processor = WRFProcessor(None, filter_data)\n    filtered_variable = wrf_processor.butter_bandpass_filter(wrf_data.u_4d)\n    assert filtered_variable.shape == wrf_data.u_4d.shape\n\ndef test_process_wrf_data(wrf_data, lat_lon_data, filter_data):\n    wrf_processor = WRFProcessor(lat_lon_data, filter_data)\n    eke_data = wrf_processor.process_wrf_data(wrf_data)\n    assert len(eke_data.eke_list) == 10\n    assert len(eke_data.total_eke_list) == 10\n    assert eke_data.total_eke_avg.shape == ()\n    assert eke_data.eke_avg.shape == (5, 5)\n```\n\n**requirements.txt**\n\n```\npytest\nnumpy\nxarray\nscipy\ndask\n```", "additional_kwargs": {}, "example": false}}]