[{"type": "system", "data": {"content": "You are an expert in optimizing scientific computations on HPC systems. \nYou will help this scientist take their existing code and turn it into a Jupyter notebook \nutilizing dask with improved performance (faster, more interactive).\n\nUseful to know:\nYou almost always put different classes in different files.\nFor Python, you always create an appropriate requirements.txt file.\nFor NodeJS, you always create an appropriate package.json file.\nYou always add a comment briefly describing the purpose of the function definition.\nYou try to add comments explaining very complex bits of logic.\nYou always follow the best practices for the requested languages in terms of describing the code written as a defined\npackage/project.\n\n\nPython toolbelt preferences:\n- pytest\n- dataclasses\n", "additional_kwargs": {}}}, {"type": "human", "data": {"content": "Instructions: I have this scientific computation that I wrote. \nI would like to optimize it such that it runs faster (utilizing parallel computation) and is more interactive.\nI will be running this on an HPC system that has support for dask and slurm.\nI will want to interact with the computation via a Jupyter notebook.\n", "additional_kwargs": {}, "example": false}}, {"type": "human", "data": {"content": "The core classes, functions, and methods that will be necessary are:\n\n1. `lat_lon()`: A function to get the map projection and the lat and lon values from the WRF data.\n2. `butter_bandpass_filter()`: A function to filter variables for waves with periods between 3-5 days using a Butterworth bandpass filter.\n3. `plot_eke()`: A function to generate the plot for the EKE distribution.\n4. `main()`: The main function that performs the computation and generates the plot.\n\nNow, let's proceed with the implementation of the code.\n\n**wrf_eke_nersc_ex.ipynb**\n\n```python\nimport os\nfrom netCDF4 import Dataset\nimport numpy as np\nimport xarray as xr\nimport wrf as wrf\nfrom datetime import datetime\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nfrom matplotlib import rcParams\nimport matplotlib.patches as mpatches\nfrom matplotlib.backends.backend_pdf import PdfPages\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nfrom scipy import signal\nimport scipy.ndimage as ndimage\nimport dask.array as da\nfrom dask.distributed import Client, LocalCluster\n\n# This program calculates the eddy kinetic energy and plots the meridional\n# distribution. The equation used is EKE = [u'^2+v'^2]/2g\n# [ ] indicates a zonal average \n\n# This is a function to get the map projection and the lat and lon values from the WRF data\ndef lat_lon():\n    file_location = '/global/cscratch1/sd/ebercosh/WRF_TCM/Historical/wrfout_d01_2008-07-01_00_00_00'\n    data = Dataset(file_location)\n    # get lat and lon values\n    # get the latitude and longitude at a single time (since they don't change with time)\n    lat = wrf.getvar(data, \"lat\") # ordered lat, lon\n    lon = wrf.getvar(data, \"lon\") # ordered lat, lon\n    # get the cropping indices since we don't want the lat/lon for the entire domain\n    lon_index_west, lat_index_south = wrf.ll_to_xy(data,-10.,-40., meta=False) # 10S, 40W\n    lon_index_east, lat_index_north = wrf.ll_to_xy(data,40.,30., meta=False) # 40N, 30E\n    lat_crop = lat.values[lat_index_south:lat_index_north+1,lon_index_west:lon_index_east+1]\n    lon_crop = lon.values[lat_index_south:lat_index_north+1,lon_index_west:lon_index_east+1]\n    # get more zoomed in cropping indices\n    lon_west = -20. # 20W\n    lon_east = 20. # 20E\n    lat_north = 20. # 20N\n    lat_south = 0. # 0N\n    lat_index_north = np.argmin((np.abs(lat_crop - lat_north)), axis=0)[0]\n    lat_index_south = np.argmin((np.abs(lat_crop - lat_south)), axis=0)[0] \n    lon_index_west = (np.abs(lon_crop - lon_west)).argmin() \n    lon_index_east = (np.abs(lon_crop - lon_east)).argmin() \n\n    return lat_crop, lon_crop, lat_index_north, lat_index_south, lon_index_west, lon_index_east\n\n\n# filtering function to filter variables for waves with periods between 3-5 days \n# takes a variable where the first index (farthest to the left) must be time\n# returns a variable of the same dimensions as the original that has been temporally \n# filtered for 3-5 days using a Butterworth bandpass filter\ndef butter_bandpass_filter(variable):\n    print(\"Temporal filter...\")\n    order = 6  # order of filtering, 6 is common\n    fs = 1/6  # sampling rate is 1 sample every six hours\n    nyq = .5 * fs  # Nyquist frequency is 1/2 times the sampling rate\n    big_period_day = 5.0    # band start (longer period)\n    small_period_day = 3.0  # band end\n    big_period_hr = big_period_day*24.0  # convert the days to hours\n    small_period_hr = small_period_day*24.0\n    low_frequency = (1/big_period_hr) / nyq     # 1 over the period to get the frequency and then\n    high_frequency = (1/small_period_hr) / nyq  # divide by the Nyquist frequency to normalize\n    print(low_frequency)\n    print(high_frequency)\n    b, a = signal.butter(order, [low_frequency, high_frequency], btype='bandpass')\n    # works on axis 0 (time)\n    filtered_variable = signal.lfilter(b, a, variable, axis=0)\n    return filtered_variable\n\n\ndef plot_eke(lat, eke_avg):\n    # smooth array for plotting\n    eke_smooth = ndimage.gaussian_filter(eke_avg, sigma=0.9, order=0)\n\n    # create plot\n    fig, ax = plt.subplots()\n    clevels = np.linspace(-8,8,33) #np.linspace(-14,14,29)  # contour levels\n    cmap = plt.cm.PuOr \n    units = '$\\mathrm{m}^{2}$ $\\mathrm{s}^{-2}$'\n    # define pressure levels for vertical cross setion\n    p_levels = np.linspace(1000,100,19)\n    # mesh the lat and vertical level values\n    X,Y = np.meshgrid(lat[:,0],p_levels)  \n    plt.xlabel(\"Latitude\")\n    plt.ylabel(\"Pressure (hPa)\")\n    contours_fill = plt.contourf(X,Y,eke_avg, cmap=cmap, levels=clevels, extend=\"both\")\n    ax.set_xlim(-5,25)\n    plt.minorticks_on()\n    plt.gca().invert_yaxis()  # invert y axis, gca stands for \"get current axis\" and is a helper function\n\n    cbar = plt.colorbar(contours_fill,  shrink = .58, orientation='horizontal') #, pad=.09) #shrink = .75,\n\n    # square up plot axes\n    ax.set_aspect(1./ax.get_data_ratio())\n\n    # save figure as a PDF\n    fig.savefig('WRF_TCM_M-O_2001-2010avg_' + scenario_type + '_EKE.pdf', bbox_inches='tight')\n\n\ndef main():\n    # set scenario type\n    scenario_type = 'Historical'   #'Historical' # 'late_century'\n\n    g = 9.8  # m/s^2 gravity acceleration\n\n    # get cropped lat and lon\n    lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east = lat_lon() \n\n    # define two lists for holding EKE values over the ten years\n    eke_list = []\n    total_eke_list = []\n\n    # loop through years\n    for year in range(2001,2011):\n        print('Year =', year)\n        # location of WRF file\n        file_location = '/global/cscratch1/sd/ebercosh/WRF_TCM/' + scenario_type + '/' + str(year) + '/'\n\n        # get u and v\n        u_data = xr.open_dataset(file_location + 'ua_' + scenario_type + '_' + str(year) + '.nc')\n        v_data = xr.open_dataset(file_location + 'va_' + scenario_type + '_' + str(year) + '.nc')\n        u_4d_full = u_data.ua # this is for May-November, ordered time, lev, lat, lon\n        v_4d_full = v_data.va # this is for May-November, ordered time, lev, lat, lon\n        print(u_4d_full.shape)\n        u_4d = u_4d_full[:-120,:,:,:] # don't include November, so go only to -120 (30 days * 4 times each day)\n        v_4d = v_4d_full[:-120,:,:,:] # don't include November, so go only to -120 (30 days * 4 times each day)\n        print(u_4d.shape)\n\n        # spatially filter u and v\n        u_temp_filt = butter_bandpass_filter(u_4d)\n        v_temp_filt = butter_bandpass_filter(v_4d)\n\n        # square u' and v'\n        uu = np.square(u_temp_filt)\n        vv = np.square(v_temp_filt)\n\n        # time average (on dim 0), order will then be lev, lat, lon\n        uu_3d = np.mean(uu, axis = 0) \n        vv_3d = np.mean(vv, axis = 0) \n\n        # calculate u'^2 + v'^2 \n        uu_vv_3d = uu_3d + vv_3d\n\n        # zonal average\n        uu_vv_2d = np.mean(uu_vv_3d[:,:,lon_index_west:lon_index_east+1], axis = 2) # order will be lev, lat\n\n        # multiply by 0.5; then append eke_2d to the eke_list\n        eke_2d = 0.5*uu_vv_2d\n        eke_list.append(eke_2d)\n        del eke_2d\n\n        # meridional average and multiply by 0.5 and divide by g\n        eke_1d = 0.5*np.mean(uu_vv_2d[:,lat_index_south:lat_index_north+1]/g, axis = 1) # order will be lev\n\n        # integrate in pressure dim; append the total_eke to the total_eke_list\n        total_eke = np.trapz(eke_1d, dx = 5000., axis=0)\n        total_eke_list.append(total_eke)\n        del total_eke\n\n    # average the lists\n    total_eke_avg = np.mean(total_eke_list, axis=0)\n    print('10 year total EKE for', scenario_type, '=', total_eke_avg, 'J/m^2')\n\n    eke_avg = np.mean(eke_list, axis=0)\n    print(eke_avg.shape)\n\n    # smooth array for plotting\n    eke_smooth = ndimage.gaussian_filter(eke_avg, sigma=0.9, order=0)\n\n    # create plot\n    fig, ax = plt.subplots()\n    clevels = np.linspace(-8,8,33) #np.linspace(-14,14,29)  # contour levels\n    cmap = plt.cm.PuOr \n    units = '$\\mathrm{m}^{2}$ $\\mathrm{s}^{-2}$'\n    # define pressure levels for vertical cross setion\n    p_levels = np.linspace(1000,100,19)\n    # mesh the lat and vertical level values\n    X,Y = np.meshgrid(lat[:,0],p_levels)  \n    plt.xlabel(\"Latitude\")\n    plt.ylabel(\"Pressure (hPa)\")\n    contours_fill = plt.contourf(X,Y,eke_avg, cmap=cmap, levels=clevels, extend=\"both\")\n    ax.set_xlim(-5,25)\n    plt.minorticks_on()\n    plt.gca().invert_yaxis()  # invert y axis, gca stands for \"get current axis\" and is a helper function\n\n    cbar = plt.colorbar(contours_fill,  shrink = .58, orientation='horizontal') #, pad=.09) #shrink = .75,\n\n    # square up plot axes\n    ax.set_aspect(1./ax.get_data_ratio())\n\n    # save figure as a PDF\n    fig.savefig('WRF_TCM_M-O_2001-2010avg_' + scenario_type + '_EKE.pdf', bbox_inches='tight')\n\nif __name__ == \"__main__\":\n    cluster = LocalCluster()\n    client = Client(cluster)\n    main()\n```\n\nIn this updated code, we have incorporated the use of Dask's built-in plotting capabilities to visualize the results directly in the notebook. The `plot_eke()` function now uses Dask arrays for the contour plot, allowing for parallel computation and improved interactivity.\n\nPlease note that the code still needs to be executed in a Jupyter notebook environment with Dask and the required packages installed.", "additional_kwargs": {}, "example": false}}, {"type": "system", "data": {"content": "You will get instructions for code to write.\nYou will write a very long answer. Make sure that every detail of the architecture is, in the end, implemented as code.\n\nThink step by step and reason yourself to the right decisions to make sure we get it right.\nYou will first lay out the names of the core classes, functions, methods that will be necessary, as well as a quick comment on their purpose.\n\nThen you will output the content of each file including ALL code.\nEach file must strictly follow a markdown code block format, where the following tokens must be replaced such that\nFILENAME is the lowercase file name including the file extension,\nLANG is the markup code block language for the code's language, and CODE is the code:\n\nFILENAME\n```LANG\nCODE\n```\n\nDo not comment on what every file does\n\nYou will start with the \"entrypoint\" file, then go to the ones that are imported by that file, and so on.\nPlease note that the code should be fully functional. No placeholders.\n\nFollow a language and framework appropriate best practice file naming convention.\nMake sure that files contain all imports, types etc. Make sure that code in different files are compatible with each other.\nEnsure to implement all code, if you are unsure, write a plausible implementation.\nInclude module dependency or package manager dependency definition file.\nBefore you finish, double check that all parts of the architecture is present in the files.\n", "additional_kwargs": {}}}, {"type": "human", "data": {"content": "Rewrite the provided code to incorporate the following improvement: \nUse dataclasses to organize and manage the input and output data.\n\nPlease now remember the steps:\n\nThink step by step and reason yourself to the right decisions to make sure we get it right.\nFirst lay out the names of the core classes, functions, methods that will be necessary, As well as a quick comment on their purpose.\n\nThen you will output the content of each file including ALL code.\nEach file must strictly follow a markdown code block format, where the following tokens must be replaced such that\nFILENAME is the lowercase file name including the file extension,\nLANG is the markup code block language for the code's language, and CODE is the code:\n\nFILENAME\n```LANG\nCODE\n```\n\nPlease note that the code should be fully functional. No placeholders.\n\nYou will start with the \"entrypoint\" file, then go to the ones that are imported by that file, and so on.\nFollow a language and framework appropriate best practice file naming convention.\nMake sure that files contain all imports, types etc. The code should be fully functional. Make sure that code in different files are compatible with each other.\nBefore you finish, double check that all parts of the architecture is present in the files.\n", "additional_kwargs": {}, "example": false}}, {"type": "ai", "data": {"content": "The core classes, functions, and methods that will be necessary are:\n\n1. `LatLonData`: A dataclass to store the latitude and longitude data.\n2. `FilterData`: A dataclass to store the filtering parameters.\n3. `EKEData`: A dataclass to store the EKE data.\n4. `WRFData`: A dataclass to store the WRF data.\n5. `WRFProcessor`: A class to perform the computation and generate the plot.\n\nNow, let's proceed with the implementation of the code.\n\n**lat_lon.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass LatLonData:\n    lat: np.ndarray\n    lon: np.ndarray\n    lat_index_north: int\n    lat_index_south: int\n    lon_index_west: int\n    lon_index_east: int\n```\n\n**filter.py**\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass FilterData:\n    order: int\n    fs: float\n    big_period_day: float\n    small_period_day: float\n    low_frequency: float\n    high_frequency: float\n```\n\n**eke.py**\n\n```python\nfrom dataclasses import dataclass\nimport numpy as np\n\n@dataclass\nclass EKEData:\n    eke_list: list[np.ndarray]\n    total_eke_list: list[float]\n    total_eke_avg: float\n    eke_avg: np.ndarray\n```\n\n**wrf.py**\n\n```python\nfrom dataclasses import dataclass\nimport xarray as xr\n\n@dataclass\nclass WRFData:\n    u_data: xr.Dataset\n    v_data: xr.Dataset\n    u_4d_full: xr.DataArray\n    v_4d_full: xr.DataArray\n    u_4d: xr.DataArray\n    v_4d: xr.DataArray\n    lat_index_south: int\n    lat_index_north: int\n    lon_index_west: int\n    lon_index_east: int\n```\n\n**wrf_processor.py**\n\n```python\nfrom netCDF4 import Dataset\nimport numpy as np\nimport xarray as xr\nimport wrf as wrf\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nfrom matplotlib import rcParams\nimport matplotlib.patches as mpatches\nfrom matplotlib.backends.backend_pdf import PdfPages\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nfrom scipy import signal\nimport scipy.ndimage as ndimage\nimport dask.array as da\nfrom dask.distributed import Client, LocalCluster\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom eke import EKEData\nfrom wrf import WRFData\n\nclass WRFProcessor:\n    def __init__(self, lat_lon_data: LatLonData, filter_data: FilterData):\n        self.lat_lon_data = lat_lon_data\n        self.filter_data = filter_data\n\n    def butter_bandpass_filter(self, variable):\n        print(\"Temporal filter...\")\n        b, a = signal.butter(self.filter_data.order, [self.filter_data.low_frequency, self.filter_data.high_frequency], btype='bandpass')\n        filtered_variable = signal.lfilter(b, a, variable, axis=0)\n        return filtered_variable\n\n    def plot_eke(self, lat, eke_avg):\n        fig, ax = plt.subplots()\n        clevels = np.linspace(-8, 8, 33)\n        cmap = plt.cm.PuOr\n        units = '$\\mathrm{m}^{2}$ $\\mathrm{s}^{-2}$'\n        p_levels = np.linspace(1000, 100, 19)\n        X, Y = np.meshgrid(lat[:, 0], p_levels)\n        plt.xlabel(\"Latitude\")\n        plt.ylabel(\"Pressure (hPa)\")\n        contours_fill = plt.contourf(X, Y, eke_avg, cmap=cmap, levels=clevels, extend=\"both\")\n        ax.set_xlim(-5, 25)\n        plt.minorticks_on()\n        plt.gca().invert_yaxis()\n        cbar = plt.colorbar(contours_fill, shrink=.58, orientation='horizontal')\n        ax.set_aspect(1. / ax.get_data_ratio())\n        fig.savefig('WRF_TCM_M-O_2001-2010avg_' + scenario_type + '_EKE.pdf', bbox_inches='tight')\n\n    def process_wrf_data(self, wrf_data: WRFData) -> EKEData:\n        lat = wrf_data.lat\n        lon = wrf_data.lon\n        lat_index_north = wrf_data.lat_index_north\n        lat_index_south = wrf_data.lat_index_south\n        lon_index_west = wrf_data.lon_index_west\n        lon_index_east = wrf_data.lon_index_east\n\n        eke_list = []\n        total_eke_list = []\n\n        for year in range(2001, 2011):\n            print('Year =', year)\n            file_location = '/global/cscratch1/sd/ebercosh/WRF_TCM/' + scenario_type + '/' + str(year) + '/'\n\n            u_data = xr.open_dataset(file_location + 'ua_' + scenario_type + '_' + str(year) + '.nc')\n            v_data = xr.open_dataset(file_location + 'va_' + scenario_type + '_' + str(year) + '.nc')\n            u_4d_full = u_data.ua\n            v_4d_full = v_data.va\n            u_4d = u_4d_full[:-120, :, :, :]\n            v_4d = v_4d_full[:-120, :, :, :]\n\n            u_temp_filt = self.butter_bandpass_filter(u_4d)\n            v_temp_filt = self.butter_bandpass_filter(v_4d)\n\n            uu = np.square(u_temp_filt)\n            vv = np.square(v_temp_filt)\n\n            uu_3d = np.mean(uu, axis=0)\n            vv_3d = np.mean(vv, axis=0)\n\n            uu_vv_3d = uu_3d + vv_3d\n\n            uu_vv_2d = np.mean(uu_vv_3d[:, :, lon_index_west:lon_index_east + 1], axis=2)\n\n            eke_2d = 0.5 * uu_vv_2d\n            eke_list.append(eke_2d)\n\n            eke_1d = 0.5 * np.mean(uu_vv_2d[:, lat_index_south:lat_index_north + 1] / g, axis=1)\n\n            total_eke = np.trapz(eke_1d, dx=5000., axis=0)\n            total_eke_list.append(total_eke)\n\n        total_eke_avg = np.mean(total_eke_list, axis=0)\n        eke_avg = np.mean(eke_list, axis=0)\n\n        return EKEData(eke_list=eke_list, total_eke_list=total_eke_list, total_eke_avg=total_eke_avg, eke_avg=eke_avg)\n```\n\n**main.py**\n\n```python\nfrom lat_lon import LatLonData\nfrom filter import FilterData\nfrom wrf import WRFData\nfrom wrf_processor import WRFProcessor\n\ndef main():\n    lat_lon_data = LatLonData(lat, lon, lat_index_north, lat_index_south, lon_index_west, lon_index_east)\n    filter_data = FilterData(order=6, fs=1/6, big_period_day=5.0, small_period_day=3.0, low_frequency=0.008333333333333333, high_frequency=0.016666666666666666)\n    wrf_data = WRFData(u_data, v_data, u_4d_full, v_4d_full, u_4d, v_4d, lat_index_south, lat_index_north, lon_index_west, lon_index_east)\n\n    wrf_processor = WRFProcessor(lat_lon_data, filter_data)\n    eke_data = wrf_processor.process_wrf_data(wrf_data)\n\n    eke_avg = eke_data.eke_avg\n    wrf_processor.plot_eke(lat, eke_avg)\n\nif __name__ == \"__main__\":\n    cluster = LocalCluster()\n    client = Client(cluster)\n    main()\n```\n\nIn this updated code, we have used dataclasses to organize and manage the input and output data. The `LatLonData`, `FilterData`, `EKEData`, and `WRFData` classes are defined as dataclasses to store the relevant data. The `WRFProcessor` class is responsible for performing the computation and generating the plot. The `main()` function initializes the necessary data and calls the `process_wrf_data()` method of the `WRFProcessor` class to perform the computation and generate the plot.", "additional_kwargs": {}, "example": false}}]